/**
 * Generated by orval v7.17.2 üç∫
 * Do not edit manually.
 * PlatePilot API
 * Intelligent meal planning and recipe management API
 * OpenAPI spec version: 1.0
 */
import {
  useMutation,
  useQuery
} from '@tanstack/vue-query';
import type {
  DataTag,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UseMutationOptions,
  UseMutationReturnType,
  UseQueryOptions,
  UseQueryReturnType
} from '@tanstack/vue-query';

import {
  computed,
  unref
} from 'vue';
import type {
  MaybeRef
} from 'vue';

import type {
  GetRecipeAllParams,
  GetRecipeSimilarParams,
  HandlerCreateRecipeRequest,
  HandlerErrorResponse,
  HandlerPaginatedRecipesJSON,
  HandlerRecipeJSON,
  HandlerSuggestRequest,
  HandlerSuggestResponse
} from './models';

import { customInstance } from '../mutator/custom-instance';




/**
 * Suggests recipes based on constraints and already selected recipes
 * @summary Suggest recipes for meal planning
 */
export const postMealplanSuggest = (
    handlerSuggestRequest: MaybeRef<HandlerSuggestRequest>,
 signal?: AbortSignal
) => {
      handlerSuggestRequest = unref(handlerSuggestRequest);
      
      return customInstance<HandlerSuggestResponse>(
      {url: `/mealplan/suggest`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: handlerSuggestRequest, ...(signal ? { signal }: {})
    },
      );
    }
  


export const getPostMealplanSuggestMutationOptions = <TError = HandlerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postMealplanSuggest>>, TError,{data: HandlerSuggestRequest}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof postMealplanSuggest>>, TError,{data: HandlerSuggestRequest}, TContext> => {

const mutationKey = ['postMealplanSuggest'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postMealplanSuggest>>, {data: HandlerSuggestRequest}> = (props) => {
          const {data} = props ?? {};

          return  postMealplanSuggest(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostMealplanSuggestMutationResult = NonNullable<Awaited<ReturnType<typeof postMealplanSuggest>>>
    export type PostMealplanSuggestMutationBody = HandlerSuggestRequest
    export type PostMealplanSuggestMutationError = HandlerErrorResponse

    /**
 * @summary Suggest recipes for meal planning
 */
export const usePostMealplanSuggest = <TError = HandlerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postMealplanSuggest>>, TError,{data: HandlerSuggestRequest}, TContext>, }
 , queryClient?: QueryClient): UseMutationReturnType<
        Awaited<ReturnType<typeof postMealplanSuggest>>,
        TError,
        {data: HandlerSuggestRequest},
        TContext
      > => {

      const mutationOptions = getPostMealplanSuggestMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Retrieves a single recipe by its unique identifier
 * @summary Get recipe by ID
 */
export const getRecipeId = (
    id: MaybeRef<string>,
 signal?: AbortSignal
) => {
      id = unref(id);
      
      return customInstance<HandlerRecipeJSON>(
      {url: `/recipe/${id}`, method: 'GET', ...(signal ? { signal }: {})
    },
      );
    }
  



export const getGetRecipeIdQueryKey = (id?: MaybeRef<string>,) => {
    return [
    'recipe',id
    ] as const;
    }

    
export const getGetRecipeIdQueryOptions = <TData = Awaited<ReturnType<typeof getRecipeId>>, TError = HandlerErrorResponse>(id: MaybeRef<string>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRecipeId>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  getGetRecipeIdQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getRecipeId>>> = ({ signal }) => getRecipeId(id, signal);

      

      

   return  { queryKey, queryFn, enabled: computed(() => !!(unref(id))), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getRecipeId>>, TError, TData> 
}

export type GetRecipeIdQueryResult = NonNullable<Awaited<ReturnType<typeof getRecipeId>>>
export type GetRecipeIdQueryError = HandlerErrorResponse


/**
 * @summary Get recipe by ID
 */

export function useGetRecipeId<TData = Awaited<ReturnType<typeof getRecipeId>>, TError = HandlerErrorResponse>(
 id: MaybeRef<string>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRecipeId>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetRecipeIdQueryOptions(id,options)

  const query = useQuery(queryOptions, queryClient) as UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData, TError>;

  return query;
}





/**
 * Retrieves a paginated list of all recipes
 * @summary Get all recipes (paginated)
 */
export const getRecipeAll = (
    params?: MaybeRef<GetRecipeAllParams>,
 signal?: AbortSignal
) => {
      params = unref(params);
      
      return customInstance<HandlerPaginatedRecipesJSON>(
      {url: `/recipe/all`, method: 'GET',
        params: unref(params), ...(signal ? { signal }: {})
    },
      );
    }
  



export const getGetRecipeAllQueryKey = (params?: MaybeRef<GetRecipeAllParams>,) => {
    return [
    'recipe','all', ...(params ? [params]: [])
    ] as const;
    }

    
export const getGetRecipeAllQueryOptions = <TData = Awaited<ReturnType<typeof getRecipeAll>>, TError = HandlerErrorResponse>(params?: MaybeRef<GetRecipeAllParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRecipeAll>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  getGetRecipeAllQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getRecipeAll>>> = ({ signal }) => getRecipeAll(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getRecipeAll>>, TError, TData> 
}

export type GetRecipeAllQueryResult = NonNullable<Awaited<ReturnType<typeof getRecipeAll>>>
export type GetRecipeAllQueryError = HandlerErrorResponse


/**
 * @summary Get all recipes (paginated)
 */

export function useGetRecipeAll<TData = Awaited<ReturnType<typeof getRecipeAll>>, TError = HandlerErrorResponse>(
 params?: MaybeRef<GetRecipeAllParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRecipeAll>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetRecipeAllQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData, TError>;

  return query;
}





/**
 * Retrieves all recipes that do not contain a specific allergen
 * @summary Get recipes avoiding allergen
 */
export const getRecipeAllergyId = (
    id: MaybeRef<string>,
 signal?: AbortSignal
) => {
      id = unref(id);
      
      return customInstance<HandlerRecipeJSON[]>(
      {url: `/recipe/allergy/${id}`, method: 'GET', ...(signal ? { signal }: {})
    },
      );
    }
  



export const getGetRecipeAllergyIdQueryKey = (id?: MaybeRef<string>,) => {
    return [
    'recipe','allergy',id
    ] as const;
    }

    
export const getGetRecipeAllergyIdQueryOptions = <TData = Awaited<ReturnType<typeof getRecipeAllergyId>>, TError = HandlerErrorResponse>(id: MaybeRef<string>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRecipeAllergyId>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  getGetRecipeAllergyIdQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getRecipeAllergyId>>> = ({ signal }) => getRecipeAllergyId(id, signal);

      

      

   return  { queryKey, queryFn, enabled: computed(() => !!(unref(id))), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getRecipeAllergyId>>, TError, TData> 
}

export type GetRecipeAllergyIdQueryResult = NonNullable<Awaited<ReturnType<typeof getRecipeAllergyId>>>
export type GetRecipeAllergyIdQueryError = HandlerErrorResponse


/**
 * @summary Get recipes avoiding allergen
 */

export function useGetRecipeAllergyId<TData = Awaited<ReturnType<typeof getRecipeAllergyId>>, TError = HandlerErrorResponse>(
 id: MaybeRef<string>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRecipeAllergyId>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetRecipeAllergyIdQueryOptions(id,options)

  const query = useQuery(queryOptions, queryClient) as UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData, TError>;

  return query;
}





/**
 * Creates a new recipe with the provided details
 * @summary Create a new recipe
 */
export const postRecipeCreate = (
    handlerCreateRecipeRequest: MaybeRef<HandlerCreateRecipeRequest>,
 signal?: AbortSignal
) => {
      handlerCreateRecipeRequest = unref(handlerCreateRecipeRequest);
      
      return customInstance<HandlerRecipeJSON>(
      {url: `/recipe/create`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: handlerCreateRecipeRequest, ...(signal ? { signal }: {})
    },
      );
    }
  


export const getPostRecipeCreateMutationOptions = <TError = HandlerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postRecipeCreate>>, TError,{data: HandlerCreateRecipeRequest}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof postRecipeCreate>>, TError,{data: HandlerCreateRecipeRequest}, TContext> => {

const mutationKey = ['postRecipeCreate'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postRecipeCreate>>, {data: HandlerCreateRecipeRequest}> = (props) => {
          const {data} = props ?? {};

          return  postRecipeCreate(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostRecipeCreateMutationResult = NonNullable<Awaited<ReturnType<typeof postRecipeCreate>>>
    export type PostRecipeCreateMutationBody = HandlerCreateRecipeRequest
    export type PostRecipeCreateMutationError = HandlerErrorResponse

    /**
 * @summary Create a new recipe
 */
export const usePostRecipeCreate = <TError = HandlerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postRecipeCreate>>, TError,{data: HandlerCreateRecipeRequest}, TContext>, }
 , queryClient?: QueryClient): UseMutationReturnType<
        Awaited<ReturnType<typeof postRecipeCreate>>,
        TError,
        {data: HandlerCreateRecipeRequest},
        TContext
      > => {

      const mutationOptions = getPostRecipeCreateMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Retrieves all recipes belonging to a specific cuisine
 * @summary Get recipes by cuisine
 */
export const getRecipeCuisineId = (
    id: MaybeRef<string>,
 signal?: AbortSignal
) => {
      id = unref(id);
      
      return customInstance<HandlerRecipeJSON[]>(
      {url: `/recipe/cuisine/${id}`, method: 'GET', ...(signal ? { signal }: {})
    },
      );
    }
  



export const getGetRecipeCuisineIdQueryKey = (id?: MaybeRef<string>,) => {
    return [
    'recipe','cuisine',id
    ] as const;
    }

    
export const getGetRecipeCuisineIdQueryOptions = <TData = Awaited<ReturnType<typeof getRecipeCuisineId>>, TError = HandlerErrorResponse>(id: MaybeRef<string>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRecipeCuisineId>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  getGetRecipeCuisineIdQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getRecipeCuisineId>>> = ({ signal }) => getRecipeCuisineId(id, signal);

      

      

   return  { queryKey, queryFn, enabled: computed(() => !!(unref(id))), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getRecipeCuisineId>>, TError, TData> 
}

export type GetRecipeCuisineIdQueryResult = NonNullable<Awaited<ReturnType<typeof getRecipeCuisineId>>>
export type GetRecipeCuisineIdQueryError = HandlerErrorResponse


/**
 * @summary Get recipes by cuisine
 */

export function useGetRecipeCuisineId<TData = Awaited<ReturnType<typeof getRecipeCuisineId>>, TError = HandlerErrorResponse>(
 id: MaybeRef<string>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRecipeCuisineId>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetRecipeCuisineIdQueryOptions(id,options)

  const query = useQuery(queryOptions, queryClient) as UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData, TError>;

  return query;
}





/**
 * Retrieves all recipes containing a specific ingredient
 * @summary Get recipes by ingredient
 */
export const getRecipeIngredientId = (
    id: MaybeRef<string>,
 signal?: AbortSignal
) => {
      id = unref(id);
      
      return customInstance<HandlerRecipeJSON[]>(
      {url: `/recipe/ingredient/${id}`, method: 'GET', ...(signal ? { signal }: {})
    },
      );
    }
  



export const getGetRecipeIngredientIdQueryKey = (id?: MaybeRef<string>,) => {
    return [
    'recipe','ingredient',id
    ] as const;
    }

    
export const getGetRecipeIngredientIdQueryOptions = <TData = Awaited<ReturnType<typeof getRecipeIngredientId>>, TError = HandlerErrorResponse>(id: MaybeRef<string>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRecipeIngredientId>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  getGetRecipeIngredientIdQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getRecipeIngredientId>>> = ({ signal }) => getRecipeIngredientId(id, signal);

      

      

   return  { queryKey, queryFn, enabled: computed(() => !!(unref(id))), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getRecipeIngredientId>>, TError, TData> 
}

export type GetRecipeIngredientIdQueryResult = NonNullable<Awaited<ReturnType<typeof getRecipeIngredientId>>>
export type GetRecipeIngredientIdQueryError = HandlerErrorResponse


/**
 * @summary Get recipes by ingredient
 */

export function useGetRecipeIngredientId<TData = Awaited<ReturnType<typeof getRecipeIngredientId>>, TError = HandlerErrorResponse>(
 id: MaybeRef<string>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRecipeIngredientId>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetRecipeIngredientIdQueryOptions(id,options)

  const query = useQuery(queryOptions, queryClient) as UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData, TError>;

  return query;
}





/**
 * Finds recipes similar to the specified recipe using vector search
 * @summary Get similar recipes
 */
export const getRecipeSimilar = (
    params: MaybeRef<GetRecipeSimilarParams>,
 signal?: AbortSignal
) => {
      params = unref(params);
      
      return customInstance<HandlerRecipeJSON[]>(
      {url: `/recipe/similar`, method: 'GET',
        params: unref(params), ...(signal ? { signal }: {})
    },
      );
    }
  



export const getGetRecipeSimilarQueryKey = (params?: MaybeRef<GetRecipeSimilarParams>,) => {
    return [
    'recipe','similar', ...(params ? [params]: [])
    ] as const;
    }

    
export const getGetRecipeSimilarQueryOptions = <TData = Awaited<ReturnType<typeof getRecipeSimilar>>, TError = HandlerErrorResponse>(params: MaybeRef<GetRecipeSimilarParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRecipeSimilar>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  getGetRecipeSimilarQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getRecipeSimilar>>> = ({ signal }) => getRecipeSimilar(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getRecipeSimilar>>, TError, TData> 
}

export type GetRecipeSimilarQueryResult = NonNullable<Awaited<ReturnType<typeof getRecipeSimilar>>>
export type GetRecipeSimilarQueryError = HandlerErrorResponse


/**
 * @summary Get similar recipes
 */

export function useGetRecipeSimilar<TData = Awaited<ReturnType<typeof getRecipeSimilar>>, TError = HandlerErrorResponse>(
 params: MaybeRef<GetRecipeSimilarParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRecipeSimilar>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetRecipeSimilarQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData, TError>;

  return query;
}





